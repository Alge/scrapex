(* ======================================== *)
(*     The ScrapScript Language Grammar     *)
(* ======================================== *)

(* --- Top-Level Structure --- *)
(* A program consists of zero or more expressions, separated by ";" *)
(* At the end of a program there might be any number of semicolons (including 0) *)

program ::= [expression (";" expression)*] ";"*

(* --- Expressions ---*)
(* Expressions consist of a prefix expression followed by any number *)
(* of infix operations. This corresponds to the Pratt parser implemented *)

expression ::= prefix_expression (infix_operation)*

(* Type annotations are just a expression with a ":" operator *)
(* expression ::= type_annotation | prefix_expression (infix_operation)* *)
(* type_annotation ::= prefix_expression ":" type_definition *)

pattern_match_expression ::= ("|" pattern "->" expression)+

pattern ::= literal
          | IDENTIFIER  
          | "_"
          | list_pattern
          | record_pattern
          | variant_pattern
          | text_pattern

list_pattern ::= "[" "]"
               | "[" pattern ("," pattern)* "]" 
               | "[" pattern ("," pattern)* "]" "++" pattern
               | pattern ">+" pattern

text_pattern ::= TEXT "++" pattern

variant_pattern ::= "#" IDENTIFIER [pattern]*

record_pattern ::= "{" [record_pattern_field ("," record_pattern_field)*] "}"
record_pattern_field ::= IDENTIFIER "=" pattern | ".." pattern

infix_operation ::= infix_operator expression

prefix_expression ::= IDENTIFIER
                    | unary_expression  
                    | "(" expression ")"
                    | literal
                    | pattern_match_expression
                    | record_expression
                    | variant_construction
                    | list_literal
                    | function_application
                    | variant_literal


(* The top-level rule for a type definition. *)
type_definition ::= [generic_params] variant_declaration+

(* The optional generic parameters, e.g., "e => v =>" *)
generic_params ::= (IDENTIFIER "=>")+

(* A single variant in a definition, e.g., "#ok v" or "#vanilla" *)
variant_declaration ::= "#" IDENTIFIER type_expression*

(* The rule for a type, which handles functions, records, and grouping. *)
type_expression ::= primary_type_expression ["->" type_expression]

(* The "atomic" parts of a type expression. *)
primary_type_expression ::= IDENTIFIER
                          | record_type
                          | "(" type_expression ")"


(* The syntax for a record type, e.g., "{ name : text }" *)
record_type ::= "{" [record_type_field ("," record_type_field)*] "}"
record_type_field ::= IDENTIFIER ":" type_expression

(* A simple variant used as a value, e.g., "#true" *)
variant_literal ::= "#" IDENTIFIER

function_application ::= prefix_expression (prefix_expression)+

list_literal ::= "[" [ expression ("," expression)* ] "]"

record_expression ::= "{" [record_field ("," record_field)*] "}"
record_field ::= IDENTIFIER "=" expression | ".." expression

variant_construction ::= IDENTIFIER "::" IDENTIFIER prefix_expression*

unary_expression ::= prefix_operator expression

(* Binary expressions are implicit from the above, as *)
(* "expression infix_operator expression" already matches the rules *)

infix_operator ::= ";" | "=" | ":" | "::" | "->" | "+" | "-" | "*" | "/" 
                 | "++" | "+<" | ">+" | ">>" | "|>" | "."

prefix_operator ::= "-" | "!" | "#" | "$$" | "@"

literal ::= INTEGER | FLOAT | TEXT | INTERPOLATED_TEXT | HEX_BYTE | BASE64 | HOLE

(* ======================================================= *)
(*   Precedence and Associativity Table                    *)
(* ======================================================= *)
(* ------------------------------------------------------- *)
(*    Operator   | Type  | Precedence | Associativity      *)
(* ------------------------------------------------------- *)
(*   ;           | Infix | 1      | Right                  *)
(*   =           | Infix | 2      | Right                  *)
(*   :           | Infix | 3      | Right                  *)
(*   |>          | Infix | 4      | Left                   *)
(*   >>          | Infix | 6      | Left                   *)
(*   ->          | Infix | 7      | Right                  *)
(*   ::          | Infix | 8      | Left                   *)
(*   ++          | Infix | 9      | Right                  *)
(*   + -         | Infix | 10     | Left                   *)
(*   +< >+       | Infix | 11     | Left                   *)
(*   * /         | Infix | 20     | Left                   *)
(*   - ! # $$ @  | Prefix| 30     | (N/A - Right)          *)
(*   .           | Infix | 35     | Left                   *)
(*   App         | Infix | 40     | Left (implicit)        *)
(* ------------------------------------------------------- *)